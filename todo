TODO:

- change scaleName 1:1 to fullSize, add parsing for <num>:<num>
	- add very large and very small units (e.g. for maps, microbes)

- set up Options class to handle defaults-and-sets intuitively
	(and make sure annotation displays them correctly)
- add "Notes on measurements and coordinate systems" that explains
	"World" coords vs. "Printer" coords.

- try just comp.render(pen), so user never sees board and xform
- figure out how to add text
- figure out how to add PNG pictures
- add "Terminology" section of comments
	- scale:  "scaleName"/"HO", "scaleRatio"/87.1, "Scale" class
	- piece: no class, just top-level Component

- add BezierControlPoint class, test it, explain it (w/ web refs)
- try enhancement to packing
	- at each stage after a page is packed "full", rotate
	all the unpacked ones and try again (negative shift sizes)
- do NOT cache xformed Points, much safer to let point be immutable,
	just recalc x and y when needed
- add a Piece.priority level to manually force sort-order
- add code for nested Components
	test with translate, scale, rotate of subcomponents
- create a BasicHouse class to demonstrate/test all the main features
	use a separate BasicHouse.js file

- learn to mock pdf class, write appropriate tests

- add options to pen (for color, closed, etc.)
- always include a Ruler Component (to allow verification that it is
	printed as the correct size)
- figure out how to discover margins on pdf page (area not physically
	reachable by printers) and arrange to avoid them
	(maybe use options printerMargin, printerLeftMargin, etec.)
- add in-line doc to every function explaining the args

- improve bin-packing
	(1) quick-and-dirty, do it in both portrait and landscape modes,
		pick the one that works best
    	(2) try having both portrait and landscape pages, assign to best match
	(3) do a best-fit but try each piece both normal and rotated

- write a User Guide document, for the different levels of users
- add a feature to Component so it knows its own bounding box, and
    auto-verifies that all drawing stays "inside the lines", and
    all sub-components stay inside the bounding box.
- create a "generate.js" file and a "generate.html" file, each with
    bare-minimum code to load the libraries, create a kit, and render it,
    make sure works correctly both ways

- get simple HTML and JS hosted on XNet (or Google Drive/Blogger/?)
    figure out how URLs work to make it testable from local copy

- add input-options mechanism for setting params from either
    the web interface or the API level (includes scale/HO, etc.)

- figure out how to fill w/ a "texture" (code)
	- figure out how to crop texture filling

- automatically add cutting-margins around each Piece, and overlap
	those intelligently with edge-of-page margins
- figure out a way to partition/divide Pieces that are too big to
	fit on a standard sheet of paper
- add a feature where you can include signs in your components (being
	careful to get rotation of text to match everything else)
- when we do tabs, figure out a reasonable way to choose the "tab width"
	and "number of tab divisions", and also how to number them so
	you can match pieces up correctly  (numbers must be assigned
	dynamically)
- allow kits to include other kits

- add a bunch of color capability
- figure out how to do "annotations" embedded in PDF file (to record
	creation-date and all options, i.e. how to reproduce this file).
- maybe add "option" to select different paper sizes
- add "themes" for collections of Kits, e.g. New England Village,
	Wild West Frontier Town, Modern Subdivision, Old Factories,
	Santa's North Pole Workshop, castles, gingerbread houses,
	dollhouses, trees & shrubs, swimming pools, etc.
	also play money, maps, molecular diagrams, rolling stock and track.
- consider making special code to do comples roof hips, design roofs as
	seaparate Pieces that are glued on top of roof "rafters"
- consider having a way to save options in a file and reload later
	(esp. in web interface, reset defaults in web page)
- add a way to custom-specify scales as 1:<num>, e.g. "1:18".

DONE:
- researched Python-vs-JavaScript, decided to go with JS because it will
    allow users to generate PDF files without installing *anything*
    on their computers (and without me doing complex hosting of back-end
    computations)
- researched and chose jspdf library for PDF generation
- got node.js installed on both ocelot and neofelis
- reviewed enough JS to start writing code
- got some skeleton code working on HTML to generate PDF with JS
- got skeleton code to work in node.js to generate PDF with JS
    (Now have proof-of-concept that JS and jspdf will work)
- researched and chose jest for unit-testing, installed on neofelis and ocelot
- got some skeleton test code working
- removed all references to paper-scissors-fun.com, replaced with
    paperscissorsfun.com, which is what I have registered at namecheap
- got git working on neofelis
- got git working on ocelot (so I can also work downstairs)
- researched matrix multiplication
- researched using matrix representation of affine transformations
- checked syntax for private members (_ just like python)
- researched, chose, installed a JS linter: jshint
- created psflib.js and psflib.test.js w/ initial fragments of code
- looked up variable parameters, added code to handle inch-only or ft+in
- cleaned up indentation to match the usual JS conventions
- added Distance class (with tests) to enforce measurement consistency
- started adding Point code for plus() and times()
- added scale factors (HO etc.)
- added transform.apply() code and tests
- added transform.compose() code and tests
- added toString() methods
- fixed up "doit" script to run tests only if jshint succeeds
- added ReflectAroundXAxis
- looked up bin-packing, found some JS code on github, downloaded it
- wired "bin-pack" package into psflib code, and added a sanity test
- changed "Point" to "DP" ("DistancePair"), use for pt, vector, size
- split tests for 3rd-party "bin-sort" into separate file for isolation
- added initial bones for Page, Kit
- added basic logic for Kit
- added basic logic for page-packing
- added a couple more Distance units
- added code for class Page and initial code for render()
- added framework for annotation (to preserve creation data)
- added more code for rendering
- got rid of parent(comp) link in DistancePair
- fleshed out arithmetic functions on Distance and DistancePair, w/ tests
- added Identity class for clarity (same as "Scale(1)")
- discover PDF page size progammatically, to allow various "format" values
- cleaned up handling of the pdf variable
- pass xform via render-chain, generated a colored-boxes PDF w/ pages!
- fixed translation of Pieces, so boxes are displayed in correct places
- cleanup: don't quote dictionary keys
- put arrows in Box class, split polygon/openPath, added styles
- changed DP to DPair for clarity
- got rid of outX() and outY()
- allow specification of PDF filename (default <ClassName.pdf>)
- researched class constants, converted all to ConversionFactor class
- added a check to see if last row of xform matrix is *ever* not 0,0,1,
    it's not, and you can prove it, but optimizing would muddle the
    code for a probably insignificant speed gain, so decided to leave
    the matrix math fully standard, at least for now.
- changed inX/inY to x/y, and removed inWidth/inHeight (no longer needed)
- created dPairify(args) as "dPairfy(dp)" or "dFairify(x, y)"
- created Piece class and cleaned up interface to bin-pack
- decided not make last row [0,0,1] of xform matrix added by parent,
    started coding it but discovered it was a bad idea
- add "numberify()" for internal and testing use only, so stop using _value


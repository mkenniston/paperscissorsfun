TODO:

- add "hand" (as in equine) to unit definitions
- change setShift to setPagePosition
- change SIZE to EXTENT
- change xform.apply() to .timesPair() -- conflict w/ JS "apply" defn
- change applyToXY -> applyToPoint (world in, printed out)
- change getWidth/Height to getExtent
- fix all Error usage to make args fit on the line (use "s + s + s" as needed)
- audit M, MPair, make sure consistent
	and doc: what is valid M-spec, MP-spec
	and make sure library and API use pairs and not separate x, y
- fix pair-arith tests (add a bunch more)
- audit tests, make sure every piece of (esp new) code has an "expect"
	and merge Distance tests w/ Measurement tests (and dPair/mPair)
- reorg test code to use new ctor/render conventions

- clean up use of bare (x, y) where we want point or vector,

- add tests for correct options set/get, annotation, propagation, and overrides
- add tests for correct positioning of subcomponents
- learn to mock pdf class, write appropriate tests

>> proofread and review all the code, make sure it is coherent
- start writing a user guide, w/ three levels:
	beginner (predefined, just download PDF files)
	intermediate (use the web interface to customize options)
	expert (write JS code to create your own Kits and Components)
		this includes the relevant API definitions

- add "Notes on measurements and coordinate systems" that explains
       "World" coords vs. "Printer" coords.

- figure out how to add text
- figure out how to add PNG pictures
-- add "Terminology" section of comments
       - scale:  "scaleName"/"HO", "scaleRatio"/87.1, "Scale" class

- audit all source, use "let" instead of "var" ??
- in tests, for  all "throw Error", verify the error message
- allow a Collection of Kits, for convenience (and efficiency for small
       scales)
- figure out how to do typed options (and maybe have a special call
	to create new ones, to guard against misspellings)
	and auto-conversion into geometry
- experiment with using internal baffels/boxes/dice to reinforce bldgs
- make a practice of printing baseplates (floors)
- work on doing a "roof" module with options for flat, slanted, single-ridge,
	gambrels, hips, T- and L- connections, dormers

- add BezierControlPoint class, test it, explain it (w/ web refs)
- try enhancement to packing
	- at each stage after a page is packed "full", rotate
	all the unpacked ones and try again (negative shift sizes)
- do NOT cache xformed Points, much safer to let point be immutable,
	just recalc x and y when needed
- add a Piece.priority level to manually force sort-order
- add a feature to map input "cardstock thickness" (printer mm)
    to "pageThickness" (world meters) -- and maybe something about
    std font height (for adding bare text to a page)

- consider finding a more strict "lint" tool to use on JS code
	also try a custom tool to verify all "._[a-z]" is preceded by "this"
- add options to pen (for color, closed, etc.)
- always include a Ruler Component (to allow verification that it is
	printed as the correct size)
- figure out how to discover margins on pdf page (area not physically
	reachable by printers) and arrange to avoid them
	(maybe use options printerMargin, printerLeftMargin, etec.)
- add in-line doc to every function explaining the args

- improve bin-packing
	(1) quick-and-dirty, do it in both portrait and landscape modes,
		pick the one that works best
    	(2) try having both portrait and landscape pages, assign to best match
	(3) do a best-fit but try each piece both normal and rotated

- write a User Guide document, for the different levels of users
- add a feature to Component so it knows its own bounding box, and
    auto-verifies that all drawing stays "inside the lines", and
    all sub-components stay inside the bounding box.
- create a "generate.js" file and a "generate.html" file, each with
    bare-minimum code to load the libraries, create a kit, and render it,
    make sure works correctly both ways

- get simple HTML and JS hosted on XNet (or Google Drive/Blogger/?)
    figure out how URLs work to make it testable from local copy

- add input-options mechanism for setting params from either
    the web interface or the API level (includes scale/HO, etc.)
    - three modes of operation:
	- linux/command-line
	- hosted web service
	- browser reading local files (so you can edit JS directly
		but not have to use command-line tools)
		(unpack a zip file to get started)

- figure out how to fill w/ a "texture" (code)
	- figure out how to crop texture filling

- automatically add cutting-margins around each Piece, and overlap
	those intelligently with edge-of-page margins
- figure out a way to partition/divide Pieces that are too big to
	fit on a standard sheet of paper
- add a feature where you can include signs in your components (being
	careful to get rotation of text to match everything else)
- when we do tabs, figure out a reasonable way to choose the "tab width"
	and "number of tab divisions", and also how to number them so
	you can match pieces up correctly  (numbers must be assigned
	dynamically)
- allow kits to include other kits

- add a bunch of color capability
- figure out how to do "annotations" embedded in PDF file (to record
	creation-date and all options, i.e. how to reproduce this file).
- maybe add "option" to select different paper sizes
- add "themes" for collections of Kits, e.g. New England Village,
	Wild West Frontier Town, Modern Subdivision, Old Factories,
	Santa's North Pole Workshop, castles, gingerbread houses,
	dollhouses, trees & shrubs, swimming pools, famous buildings
	(both modern and ancient), famous bridges, pyramids (Egypt,
	Mexico, et.al.), rockets and missiles, ships, radio towers,
	etc.
	also play money, maps, molecular diagrams, rolling stock and track.
- consider making special code to do comples roof hips, design roofs as
	seaparate Pieces that are glued on top of roof "rafters"
- consider having a way to save options in a file and reload later
	(esp. in web interface, reset defaults in web page)
- add a way to custom-specify scales as 1:<num>, e.g. "1:18".

DONE:
- researched Python-vs-JavaScript, decided to go with JS because it will
    allow users to generate PDF files without installing *anything*
    on their computers (and without me doing complex hosting of back-end
    computations)
- researched and chose jspdf library for PDF generation
- got node.js installed on both ocelot and neofelis
- reviewed enough JS to start writing code
- got some skeleton code working on HTML to generate PDF with JS
- got skeleton code to work in node.js to generate PDF with JS
    (Now have proof-of-concept that JS and jspdf will work)
- researched and chose jest for unit-testing, installed on neofelis and ocelot
- got some skeleton test code working
- removed all references to paper-scissors-fun.com, replaced with
    paperscissorsfun.com, which is what I have registered at namecheap
- got git working on neofelis
- got git working on ocelot (so I can also work downstairs)
- researched matrix multiplication
- researched using matrix representation of affine transformations
- checked syntax for private members (_ just like python)
- researched, chose, installed a JS linter: jshint
- created psflib.js and psflib.test.js w/ initial fragments of code
- looked up variable parameters, added code to handle inch-only or ft+in
- cleaned up indentation to match the usual JS conventions
- added Distance class (with tests) to enforce measurement consistency
- started adding Point code for plus() and times()
- added scale factors (HO etc.)
- added transform.apply() code and tests
- added transform.compose() code and tests
- added toString() methods
- fixed up "doit" script to run tests only if jshint succeeds
- added ReflectAroundXAxis
- looked up bin-packing, found some JS code on github, downloaded it
- wired "bin-pack" package into psflib code, and added a sanity test
- changed "Point" to "DP" ("DistancePair"), use for pt, vector, size
- split tests for 3rd-party "bin-sort" into separate file for isolation
- added initial bones for Page, Kit
- added basic logic for Kit
- added basic logic for page-packing
- added a couple more Distance units
- added code for class Page and initial code for render()
- added framework for annotation (to preserve creation data)
- added more code for rendering
- got rid of parent(comp) link in DistancePair
- fleshed out arithmetic functions on Distance and DistancePair, w/ tests
- added Identity class for clarity (same as "Scale(1)")
- discover PDF page size progammatically, to allow various "format" values
- cleaned up handling of the pdf variable
- pass xform via render-chain, generated a colored-boxes PDF w/ pages!
- fixed translation of Pieces, so boxes are displayed in correct places
- cleanup: don't quote dictionary keys
- put arrows in Box class, split polygon/openPath, added styles
- changed DP to DPair for clarity
- got rid of outX() and outY()
- allow specification of PDF filename (default <ClassName.pdf>)
- researched class constants, converted all to ConversionFactor class
- added a check to see if last row of xform matrix is *ever* not 0,0,1,
    it's not, and you can prove it, but optimizing would muddle the
    code for a probably insignificant speed gain, so decided to leave
    the matrix math fully standard, at least for now.
- changed inX/inY to x/y, and removed inWidth/inHeight (no longer needed)
- created dPairify(args) as "dPairfy(dp)" or "dFairify(x, y)"
- created Piece class and cleaned up interface to bin-pack
- decided not make last row [0,0,1] of xform matrix added by parent,
    started coding it but discovered it was a bad idea
- add "numberify()" for internal and testing use only, so stop using _value
- changed Scale to Resize to avoid confusion with things like "HO scale"
- changed ConversionFactors class to have static getter methods instead of
    just storing hashes, to allow progammatic parsing of ratios like "1:200".
- changed "numberify" to "numerify" because it sounds much better
- added parsing of custom scale factors like "1:00"
- inverted scale ratio, to make "1:120" be "1/120", i.e. what it really means
- added very large and very small units (e.g. for maps, microbes), with
    better parsing of SI prefixes to include ALL those units
- enabled sub-components, with code to handle options and shifts appropriately
- cleaned up names (dividedBy), added function (distanceBetween), made
    options work right, clarified component ctor/build/render usage, added
    geometry convention for ctor to share info with render, cleaned up
    problem with positioning
- added SimpleHouse class to do very basic stuff w/ Components (and produced
    first sheet printed/cut/assembled!)
- removed class DrawingBoard and simplified Component.render to "render(pen)"
- removed an invalid Kit.ctor in SimpleHouse
- removed Component.build, added comments to clarify the functions of
    the constructor and render() methods
- Phase 1: created new Measurement class, with tests
- Phase 2: renamed Measurement.type to refFrame, and created new
    MeasurementPair class, with tests
- Phase 3: changed mainline code to use new M and MP classes
- Phase 4: updated SimpleHouse to use new M and MP classes
- Phase 5: moved/revised documentation (comments) for M/MP, removed dead code

